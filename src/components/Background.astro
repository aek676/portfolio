<div class="sky-container">
  <div class="cloud cloud-1"></div>
  <div class="cloud cloud-2"></div>
  <div class="cloud cloud-3"></div>
  <div class="cloud cloud-4"></div>
</div>

<style>
  .sky-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: linear-gradient(
      var(--color-sky-top) 0%,
      var(--color-horizon) 60%,
      #4b3621 100%
    );
    z-index: -2;
    overflow: hidden;
    pointer-events: none;
  }

  .cloud {
    position: absolute;
    background: radial-gradient(
      ellipse at center,
      rgba(255, 255, 255, 1) 0%,
      rgba(255, 255, 255, 0) 70%
    );
    border-radius: 50%;
    filter: blur(10px);
    opacity: 0.95;
    animation: floatCloud linear infinite;
    will-change: transform;
    transform: translateZ(0); /* Forzar GPU acceleration */
  }

  /* Optimización para dispositivos bajos */
  .low-performance .cloud {
    filter: blur(5px); /* Reducir blur */
    animation-duration: 80s; /* Más lento */
  }

  .minimal-performance .cloud {
    filter: none; /* Sin blur */
    animation-duration: 120s; /* Mucho más lento */
  }

  /* Ocultar nubes según configuración */
  .cloud.hidden-medium,
  .cloud.hidden-low,
  .cloud.hidden-minimal {
    display: none;
  }

  /* Media queries para responsive */
  @media (max-width: 768px) {
    .cloud {
      animation-duration: 60s; /* Más lento en móvil */
    }
  }

  @media (max-width: 480px) {
    .cloud {
      filter: blur(5px);
      animation-duration: 80s;
    }
  }

  /* Fallback para dispositivos sin WebGL */
  .no-webgl .sky-container {
    background: linear-gradient(
      var(--color-sky-top) 0%,
      var(--color-horizon) 50%,
      #4b3621 100%
    );
  }

  .no-webgl .cloud {
    display: none;
  }

  /* Fallback minimal */
  .no-webgl.minimal-performance .sky-container {
    background: linear-gradient(
      var(--color-sky-top) 0%,
      var(--color-horizon) 100%
    );
  }

  .cloud-1 {
    width: 500px;
    height: 200px;
    top: 5%;
    left: -20%;
    animation-duration: 45s;
    animation-delay: 0s;
  }

  .cloud-2 {
    width: 700px;
    height: 300px;
    top: 15%;
    left: -20%;
    opacity: 0.6;
    animation-duration: 65s;
    animation-delay: -20s;
  }

  .cloud-3 {
    width: 300px;
    height: 150px;
    top: 25%;
    left: -10%;
    opacity: 0.5;
    animation-duration: 35s;
    animation-delay: -5s;
  }

  .cloud-4 {
    width: 600px;
    height: 250px;
    top: -5%;
    left: -10%;
    opacity: 0.7;
    animation-duration: 55s;
    animation-delay: -30s;
  }

  @keyframes floatCloud {
    from {
      transform: translateX(-100%);
    }
    to {
      transform: translateX(120vw);
    }
  }
</style>

<script>
  import * as THREE from 'three';

  // Sistema de detección de capacidades del dispositivo
  class DevicePerformanceDetector {
    capabilities: any;
    performanceTier: string;

    constructor() {
      this.capabilities = this.detectCapabilities();
      this.performanceTier = this.calculatePerformanceTier();
    }

    detectCapabilities() {
      const canvas = document.createElement('canvas');
      const gl = (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')) as WebGLRenderingContext | null;
      
      return {
        // Detección de GPU
        gpu: {
          vendor: gl?.getParameter(gl.VENDOR) || 'unknown',
          renderer: gl?.getParameter(gl.RENDERER) || 'unknown',
          maxTextureSize: gl?.getParameter(gl.MAX_TEXTURE_SIZE) || 0,
          maxVertexTextureImageUnits: gl?.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) || 0
        },
        // Detección de hardware
        hardware: {
          cores: navigator.hardwareConcurrency || 4,
          deviceMemory: (navigator as any).deviceMemory || 4,
          pixelRatio: window.devicePixelRatio || 1
        },
        // Detección de dispositivo
        device: {
          isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent),
          isTablet: /iPad|Android/i.test(navigator.userAgent) && window.innerWidth > 768,
          screenArea: window.innerWidth * window.innerHeight
        },
        // Detección de WebGL
        webgl: {
          supported: !!gl,
          version: gl?.getParameter(gl.VERSION) || 'unknown',
          maxRenderBufferSize: gl?.getParameter(gl.MAX_RENDERBUFFER_SIZE) || 0
        }
      };
    }

    calculatePerformanceTier(): string {
      const { gpu, hardware, device, webgl } = this.capabilities;
      
      let score = 0;
      
      // Puntuación por GPU
      if (gpu.maxTextureSize > 4096) score += 3;
      else if (gpu.maxTextureSize > 2048) score += 2;
      else score += 1;
      
      // Puntuación por CPU
      if (hardware.cores >= 8) score += 3;
      else if (hardware.cores >= 4) score += 2;
      else score += 1;
      
      // Puntuación por memoria
      if (hardware.deviceMemory >= 8) score += 3;
      else if (hardware.deviceMemory >= 4) score += 2;
      else score += 1;
      
      // Penalización por móvil
      if (device.isMobile) score -= 2;
      if (device.isTablet) score -= 1;
      
      // Puntuación por WebGL
      if (webgl.maxRenderBufferSize > 4096) score += 2;
      else score += 1;
      
      // Determinar tier
      if (score >= 10) return 'high';
      if (score >= 6) return 'medium';
      if (score >= 3) return 'low';
      return 'minimal';
    }
  }

  // Configuración de rendimiento por tier
  const PERFORMANCE_CONFIGS = {
    high: {
      grassCount: 450000,
      cloudCount: 4,
      pixelRatio: Math.min(window.devicePixelRatio, 2),
      antialiasing: true,
      lodEnabled: true,
      windComplexity: 1.0,
      renderDistance: 90
    },
    medium: {
      grassCount: 100000,
      cloudCount: 3,
      pixelRatio: Math.min(window.devicePixelRatio, 1.5),
      antialiasing: true,
      lodEnabled: true,
      windComplexity: 0.7,
      renderDistance: 60
    },
    low: {
      grassCount: 50000,
      cloudCount: 2,
      pixelRatio: 1,
      antialiasing: false,
      lodEnabled: false,
      windComplexity: 0.5,
      renderDistance: 40
    },
    minimal: {
      grassCount: 20000,
      cloudCount: 1,
      pixelRatio: 1,
      antialiasing: false,
      lodEnabled: false,
      windComplexity: 0.3,
      renderDistance: 30
    }
  };

  // Sistema de monitoreo de FPS
  class FPSMonitor {
    fps: number = 60;
    frames: number[] = [];
    lastFrameTime: number = performance.now();
    callbacks: ((fps: number) => void)[] = [];

    update(): void {
      const now = performance.now();
      const delta = now - this.lastFrameTime;
      this.lastFrameTime = now;
      
      this.frames.push(1000 / delta);
      if (this.frames.length > 60) {
        this.frames.shift();
      }
      
      this.fps = this.frames.reduce((a: number, b: number) => a + b, 0) / this.frames.length;
      
      // Notificar callbacks si el FPS es bajo
      if (this.fps < 30 && this.frames.length === 60) {
        this.callbacks.forEach((callback: (fps: number) => void) => callback(this.fps));
      }
    }

    onLowFPS(callback: (fps: number) => void): void {
      this.callbacks.push(callback);
    }
  }

  // Función para verificar soporte WebGL
  function checkWebGLSupport() {
    try {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      return !!gl;
    } catch (e) {
      return false;
    }
  }

  // Función para configurar nubes según rendimiento
  function setupClouds(config: typeof PERFORMANCE_CONFIGS.high): void {
    const skyContainer = document.querySelector('.sky-container');
    if (!skyContainer) return;
    
    const clouds = document.querySelectorAll('.cloud');
    
    // Añadir clase de rendimiento
    if (config.grassCount <= 50000) {
      skyContainer.classList.add('low-performance');
    }
    if (config.grassCount <= 20000) {
      skyContainer.classList.add('minimal-performance');
    }
    
    // Ocultar nubes según configuración
    clouds.forEach((cloud: Element, index: number) => {
      (cloud as HTMLElement).classList.remove('hidden-medium', 'hidden-low', 'hidden-minimal');
      
      if (index >= config.cloudCount) {
        if (config.grassCount <= 100000) {
          (cloud as HTMLElement).classList.add('hidden-medium');
        }
        if (config.grassCount <= 50000) {
          (cloud as HTMLElement).classList.add('hidden-low');
        }
        if (config.grassCount <= 20000) {
          (cloud as HTMLElement).classList.add('hidden-minimal');
        }
      }
    });
  }

  const vertexShader = `
    precision highp float;
    
    // Matrices Uniformes
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    
    // Atributos
    attribute vec3 position;
    attribute vec2 uv;
    attribute mat4 instanceMatrix;
    
    // Varyings
    varying vec2 vUv;
    varying float vHeight;
    
    // Uniforms custom
    uniform float uTime;
    uniform float uWindComplexity;

    void main() {
        vUv = uv;
        vHeight = position.y;
        
        // Optimización: usar posición mundo directamente desde instanceMatrix
        vec3 worldPos = instanceMatrix[3].xyz;
        
        // Viento simplificado y adaptativo
        float windStrength = uWindComplexity * 0.1;
        float windEffect = sin(uTime * 1.5 + worldPos.x * 0.5) * windStrength;
        
        // La fuerza del viento aumenta con la altura
        float heightFactor = pow(vHeight, 2.0);
        
        // Aplicar viento solo si es significativo
        vec3 localPos = position;
        if (uWindComplexity > 0.1) {
            localPos.x += windEffect * heightFactor;
        }
        
        // Transformación final optimizada
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(localPos, 1.0);
    }
  `;

  // Fragment Shader (RawShaderMaterial)
  const fragmentShader = `
    precision highp float;
    
    varying vec2 vUv;
    varying float vHeight;
    
    uniform vec3 uFogColor;
    uniform float uWindComplexity;

    void main() {
        // Colores base
        vec3 colorNear = vec3(0.914, 0.769, 0.416);
        vec3 colorFar = vec3(0.518, 0.663, 0.361);
        
        // Profundidad simplificada
        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float mixFactor = smoothstep(5.0, 60.0, depth);
        
        vec3 baseColor = mix(colorNear, colorFar, mixFactor);
        
        // Variación por altura (simplificada en baja calidad)
        vec3 finalColor = baseColor;
        if (uWindComplexity > 0.5) {
            finalColor *= (0.6 + 0.4 * vHeight);
            finalColor *= 0.5 + 0.5 * vHeight;
        }
        
        // Niebla adaptativa
        float fogDistance = uWindComplexity > 0.5 ? 90.0 : 60.0;
        float fogFactor = smoothstep(15.0, fogDistance, depth);
        
        gl_FragColor = vec4(mix(finalColor, uFogColor, fogFactor), 1.0);
    }
  `;

  function init() {
    // Evitar reinicialización en HMR
    if (document.querySelector('canvas[data-engine="three"]')) return;

    // Verificar soporte WebGL
    if (!checkWebGLSupport()) {
      console.warn('WebGL not supported, using CSS fallback');
      document.body.classList.add('no-webgl');
      setupClouds(PERFORMANCE_CONFIGS.minimal);
      return;
    }

    try {
      // Inicializar sistemas de rendimiento
      const deviceDetector = new DevicePerformanceDetector();
      const fpsMonitor = new FPSMonitor();
      const performanceConfig = PERFORMANCE_CONFIGS[deviceDetector.performanceTier as keyof typeof PERFORMANCE_CONFIGS];

      console.log(`Performance Tier: ${deviceDetector.performanceTier}`, performanceConfig);

      const scene = new THREE.Scene();

      // Niebla ajustada para la profundidad - COLOR VERDE
      const horizonColor = 0x84a95c;
      scene.fog = new THREE.Fog(horizonColor, 15, performanceConfig.renderDistance);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        performanceConfig.renderDistance
      );
      camera.position.set(0, 1.8, 12);
      camera.lookAt(0, 2.5, 0);

      // Renderer optimizado según capacidades
      const renderer = new THREE.WebGLRenderer({
        antialias: performanceConfig.antialiasing,
        alpha: true,
        powerPreference: 'high-performance'
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(performanceConfig.pixelRatio);
      renderer.domElement.setAttribute('data-engine', 'three');

      // Optimizaciones adicionales para dispositivos bajos
      if (deviceDetector.performanceTier === 'low' || deviceDetector.performanceTier === 'minimal') {
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.shadowMap.enabled = false;
        renderer.info.autoReset = false;
      }

      // Estilos fijos para el canvas
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.left = '0';
      renderer.domElement.style.zIndex = '-1';
      renderer.domElement.style.pointerEvents = 'none';

      document.body.appendChild(renderer.domElement);

      const geometry = new THREE.PlaneGeometry(0.08, 1.4, 1, 4);
      geometry.translate(0, 0.7, 0);

      // Material optimizado con uniforms adaptativos
      const material = new THREE.RawShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: {
          uTime: { value: 0 },
          uFogColor: { value: new THREE.Color(horizonColor) },
          uWindComplexity: { value: performanceConfig.windComplexity },
        },
        side: THREE.DoubleSide,
        transparent: true,
      });

      // Grass adaptativo según dispositivo
      const GRASS_COUNT = performanceConfig.grassCount;
      const grassMesh = new THREE.InstancedMesh(
        geometry,
        material,
        GRASS_COUNT
      );

      const dummy = new THREE.Object3D();
      // Rangos adaptativos según configuración
      const rangeX = performanceConfig.lodEnabled ? 300 : 150;
      const rangeZ = performanceConfig.lodEnabled ? 140 : 80;

      // Optimización: usar Float32Array para mejor rendimiento
      for (let i = 0; i < GRASS_COUNT; i++) {
        const x = (Math.random() - 0.5) * rangeX;
        const z = Math.random() * -rangeZ + 20;

        dummy.position.set(x, 0, z);
        dummy.rotation.y = Math.random() * Math.PI;
        dummy.scale.setScalar(0.5 + Math.random() * 1.5);
        dummy.updateMatrix();
        grassMesh.setMatrixAt(i, dummy.matrix);
      }

      grassMesh.instanceMatrix.needsUpdate = true;
      grassMesh.frustumCulled = !performanceConfig.lodEnabled;

      scene.add(grassMesh);

      // Configurar nubes según rendimiento
      setupClouds(performanceConfig);

      // Eventos
      const onResize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };
      window.addEventListener('resize', onResize);

      const onScroll = () => {
        const scrollPercent =
          window.scrollY /
          (document.documentElement.scrollHeight - window.innerHeight || 1);
        camera.position.y = 1.8 + scrollPercent * 6;
        camera.position.z = 12 - scrollPercent * 4;

        const fades = document.querySelectorAll('.section-fade');
        fades.forEach((sec) => {
          const rect = sec.getBoundingClientRect();
          if (rect.top < window.innerHeight * 0.9) {
            sec.classList.add('visible');
          }
        });
      };
      window.addEventListener('scroll', onScroll);
      onScroll(); // Init pos

      // Callback para ajuste dinámico de calidad
      fpsMonitor.onLowFPS((currentFPS: number) => {
        if (currentFPS < 25) {
          console.warn(`Low FPS detected (${currentFPS}), reducing quality`);
          // Podríamos reducir dinámicamente la calidad aquí si fuera necesario
        }
      });

      const animate = () => {
        requestAnimationFrame(animate);
        
        // Actualizar FPS monitor
        fpsMonitor.update();
        
        const time = performance.now();
        // Actualizar uniforms con configuración adaptativa
        if (material.uniforms) {
          material.uniforms.uTime.value = time * 0.001;
          material.uniforms.uWindComplexity.value = performanceConfig.windComplexity;
        }
        renderer.render(scene, camera);
      };
      animate();
    } catch (e) {
      console.error('Three.js Init Error:', e);
      // Fallback a CSS-only
      document.body.classList.add('no-webgl');
      setupClouds({ cloudCount: 1, grassCount: 0 } as any);
      
      const err = document.createElement('div');
      err.style.cssText =
        'position:fixed;top:0;left:0;background:red;color:white;padding:20px;z-index:9999';
      err.textContent =
        'Graphic Error: ' + (e instanceof Error ? e.message : String(e));
      document.body.appendChild(err);
    }
  }

  // Ejecutar inmediatamente
  init();
</script>
